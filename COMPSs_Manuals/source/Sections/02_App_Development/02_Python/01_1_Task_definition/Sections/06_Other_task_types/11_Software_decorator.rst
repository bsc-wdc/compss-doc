Software decorator
^^^^^^^^^^^^^^^^^^^
The *@software* decorator is useful in order to move definitions of several PyCOMPSs decorators
to a JSON file. It allows the users to 'define' their decorator definitions from an external file, which
can be generated by another resource. Thus, the only supported argument is the 'config_file' that
should contain the path to the JSON configuration file. Following example shows


.. code-block:: python
    :name: software_basic
    :caption: Software decorator definition example.

    from pycompss.api.task import task
    from pycompss.api.software import software

    @software(config_file="example.json")
    @task(returns=1)
    def example():
        return "hola"


Configuration files can contain different key-values depending on the user's needs. If the user
wants to define an MPI task, then "mpi" value should be set for the "type" key. Moreover, arguments
of @mpi decorator can be added inside the "properties". A basic configuration file for an MPI task
would look like in the example below:

.. code-block:: json
    :name: software_basic_json
    :caption: JSON configuration file of an MPI definition.

    {
        "type":"mpi",
        "properties":{
            "runner":"mpirun",
            "processes": 2,
            "binary":"~/app_mpi.bin"
        }
    }

As we see "runner", "processes", and "binary" are the regular parameters of @mpi decorator, and are
added to the "properties" of the @software.

If we wanted to combine @constraint and @mpi decorators together, the JSON file would have been extended:

.. code-block:: json
    :name: software_constraint_json
    :caption: JSON configuration file of an MPI definition.

    {
        "type":"mpi",
        "properties":{
            "runner":"mpirun",
            "processes": 2,
            "binary":"~/app_mpi.bin",
     		"params": "-d {{a}} {{b}}"
        },
        "constraints":{
            "computing_units": 2
        }
    }
