Programming Model
*****************

.. include:: ./01_Programming_model/01_C_application_overview_inc.rst

The following sections provide a more detailed view of the C++ Binding. It will
include the available API calls, how to deal with objects and having tasks as
method objects as well as how to define constraints
and task versions.

Binding API
===========

Besides the aforementioned **compss_on**, **compss_off** and
**compss_wait_on** functions, the C/C++ main program can make use of a
variety of other API calls to better manage the synchronization of data
generated by tasks. These calls are as follows:

void compss_ifstream(char \* filename, ifstream* \ & \* ifs)
   Given an uninitialized input stream *ifs* and a file *filename*, this
   function will synchronize the content of the file and initialize
   *ifs* to read from it.

void compss_ofstream(char \* filename, ofstream* \ & \* ofs)
   Behaves the same way as *compss_ifstream*, but in this case the
   opened stream is an output stream, meaning it will be used to write
   to the file.

FILE\* compss_fopen(char \* file_name, char \* mode)
   Similar to the C/C++ *fopen* call. Synchronizes with the last version of file
   *file_name* and returns the FILE\* pointer to further reference it.
   As the mode parameter it takes the same that can be used in *fopen*
   (*r, w, a, r+, w+* and *a+*).

void compss_wait_on(T\** \ & \* obj) or T compss_wait_on(T* \ & \* obj)
   Synchronizes for the last version of object obj, meaning that
   the execution will stop until the value of *obj* up to that point of
   the code is received (and thus all tasks that can modify it have
   ended).

void compss_delete_file(char \* file_name)
   Makes an asynchronous delete of file *filename*. When all previous tasks have
   finished updating the file, it is deleted.

void compss_delete_object(T\** \ & \* obj)
   Makes an asynchronous delete of an object. When all previous tasks have
   finished updating the object, it is deleted.

void compss_barrier()
   Similarly to the Python binding, performs
   an explicit synchronization without a return. When a
   *compss_barrier* is encountered, the execution will not continue
   until all the tasks submitted before the *compss_barrier* have
   finished.

Functions file
==============

The implementation of the tasks in a C or C++ program has to be provided
in a functions file. Its name must be the same as the main file followed
by the suffix "-functions". In our case Matmul-functions.cc.

.. code-block:: C

    #include "Matmul.h"
    #include "Matrix.h"
    #include "Block.h"

    void initMatrix(Matrix *matrix,int mSize,int nSize,double val){
         *matrix = Matrix::init(mSize, nSize, val);
    }

    void multiplyBlocks(Block *block1,Block *block2,Block *block3){
         block1->multiply(*block2, *block3);
    }

In the previous code, class methods have been encapsulated inside a
function. This is useful when the class method returns an object or a
value and we want to avoid the explicit synchronization when returning
from the method.

Additional source files
=======================

Other source files needed by the user application must be placed under
the directory "**src**". In this directory the programmer must provide a
**Makefile** that compiles such source files in the proper way. When the
binding compiles the whole application it will enter into the src
directory and execute the Makefile.

It generates two libraries, one for the master application and another
for the worker application. The directive COMPSS_MASTER or
COMPSS_WORKER must be used in order to compile the source files for
each type of library. Both libraries will be copied into the lib
directory where the binding will look for them when generating the
master and worker applications.

Class Serialization
===================

In case of using an object as method parameter, as callee or as return
of a call to a function, the object has to be serialized. The
serialization method has to be provided inline in the header file of the
object's class by means of the "**boost**" library. The next listing
contains an example of serialization for two objects of the Block class.

.. code-block:: C

    #ifndef BLOCK_H
    #define BLOCK_H

    #include    <vector>
    #include    <boost/archive/text_iarchive.hpp>
    #include    <boost/archive/text_oarchive.hpp>
    #include    <boost/serialization/serialization.hpp>
    #include    <boost/serialization/access.hpp>
    #include    <boost/serialization/vector.hpp>

    using namespace std;
    using namespace boost;
    using namespace serialization;

    class Block {
    public:
        Block(){};
        Block(int bSize);
        static Block *init(int bSize, double initVal);
        void multiply(Block block1, Block block2);
        void print();

    private:
        int M;
        std::vector< std::vector< double > > data;

        friend class::serialization::access;
        template<class Archive>
        void serialize(Archive & ar, const unsigned int version) {
            ar & M;
            ar & data;
        }
    };
    #endif

For more information about serialization using "boost" visit the related
documentation at `www.boost.org <www.boost.org>`.

Method - Task
=============

A task can be a C++ class method. A method can return a value, modify
the *this* object, or modify a parameter.

If the method has a return value there will be an implicit
synchronization before exit the method, but for the *this* object and
parameters the synchronization can be done later after the method has
finished.

This is because the *this* object and the parameters can be accessed
inside and outside the method, but for the variable where the returned
value is copied to, it can't be known inside the method.

.. code-block:: C

    #include "Block.h"

    Block::Block(int bSize) {
           M = bSize;
           data.resize(M);
           for (int i=0; i<M; i++) {
                  data[i].resize(M);
           }
    }

    Block *Block::init(int bSize, double initVal) {
           Block *block = new Block(bSize);
           for (int i=0; i<bSize; i++) {
                  for (int j=0; j<bSize; j++) {
                         block->data[i][j] = initVal;
                  }
           }
           return block;
    }

    #ifdef COMPSS_WORKER

    void Block::multiply(Block block1, Block block2) {
           for (int i=0; i<M; i++) {
                  for (int j=0; j<M; j++) {
                         for (int k=0; k<M; k++) {
                                data[i][j] += block1.data[i][k] * block2.data[k][j];
                         }
                  }
           }
           this->print();
    }

    #endif

    void Block::print() {
           for (int i=0; i<M; i++) {
                  for (int j=0; j<M; j++) {
                         cout << data[i][j] << " ";
                  }
                  cout << "\r\n";
           }
    }


Task Constraints
================

The C/C++ binding also supports the definition of task constraints. The
task definition specified in the IDL file must be decorated/annotated
with the *@Constraints*. Below, you can find and example of how to
define a task with a constraint of using 4 cores.

.. code-block:: text

    interface Matmul
    {
          @Constraints(ComputingUnits = 4)
          void multiplyBlocks(inout Block block1,
                              in Block block2,
                              in Block block3);

    };

.. include:: ./01_Programming_model/02_C_constraints_inc.rst


Task Versions
=============

Another COMPSs functionality supported in the C/C++ binding is the
definition of different versions for a tasks. The following code shows
an IDL file where a function has two implementations, with their
corresponding constraints. It show an example where the
*multiplyBlocks_GPU* is defined as a implementation of *multiplyBlocks*
using the annotation/decoration *@Implements*. It also shows how to set
a processor constraint which requires a GPU processor and a CPU core for
managing the offloading of the computation to the GPU.

.. code-block:: text

    interface Matmul
    {
            @Constraints(ComputingUnits=4);
            void multiplyBlocks(inout Block block1,
                                in Block block2,
                                in Block block3);

            // GPU implementation
            @Constraints(processors={
                   @Processor(ProcessorType=CPU, ComputingUnits=1)});
                   @Processor(ProcessorType=GPU, ComputingUnits=1)});
            @Implements(multiplyBlocks);
            void multiplyBlocks_GPU(inout Block block1,
                                    in Block block2,
                                    in Block block3);

    };
