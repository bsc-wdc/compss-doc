
As in Java, the application code is divided in 3 parts: the Task definition
interface, the main code and task implementations. These files must have the
following notation,: <app_name>.idl, for the interface file, <app_name>.cc for
the main code and <app_name>-functions.cc for task implementations. Next
paragraphs provide an example of how to define this files for matrix
multiplication parallelized by blocks.


.. rubric:: Task Definition Interface

As in Java the user has to provide a task selection by means of an
interface. In this case the interface file has the same name as the main
application file plus the suffix "idl", i.e. Matmul.idl, where the main
file is called Matmul.cc.

.. code-block:: C
    :caption: Matmul.idl

    interface Matmul
    {
          // C functions
          void initMatrix(inout Matrix matrix,
                          in int mSize,
                          in int nSize,
                          in double val);

          void multiplyBlocks(inout Block block1,
                              inout Block block2,
                              inout Block block3);
    };

The syntax of the interface file is shown in the previous code. Tasks
can be declared as classic C function prototypes, this allow to keep the
compatibility with standard C applications. In the example, initMatrix
and multiplyBlocks are functions declared using its prototype, like in a
C header file, but this code is C++ as they have objects as parameters
(objects of type Matrix, or Block).

The grammar for the interface file is:

.. code-block:: text

    ["static"] return-type task-name ( parameter {, parameter }* );

    return-type = "void" | type

    ask-name = <qualified name of the function or method>

    parameter = direction type parameter-name

    direction = "in" | "out" | "inout"

    type = "char" | "int" | "short" | "long" | "float" | "double" | "boolean" |
           "char[<size>]" | "int[<size>]" | "short[<size>]" | "long[<size>]" |
           "float[<size>]" | "double[<size>]" | "string" | "File" | class-name

    class-name = <qualified name of the class>

.. rubric:: Main Program

The following code shows an example of matrix multiplication written in C++.

.. code-block:: C
    :caption: Matrix multiplication

    #include "Matmul.h"
    #include "Matrix.h"
    #include "Block.h"
    int N; //MSIZE
    int M; //BSIZE
    double val;
    int main(int argc, char **argv)
    {
          Matrix A;
          Matrix B;
          Matrix C;

          N = atoi(argv[1]);
          M = atoi(argv[2]);
          val = atof(argv[3]);

          compss_on();

          A = Matrix::init(N,M,val);

          initMatrix(&B,N,M,val);
          initMatrix(&C,N,M,0.0);

          cout << "Waiting for initialization...\n";

          compss_wait_on(B);
          compss_wait_on(C);

          cout << "Initialization ends...\n";

          C.multiply(A, B);

          compss_off();
          return 0;
    }

The developer has to take into account the following rules:

#. A header file with the same name as the main file must be included,
   in this case **Matmul.h**. This header file is automatically
   generated by the binding and it contains other includes and
   type-definitions that are required.

#. A call to the **compss_on** binding function is required to turn on
   the COMPSs runtime.

#. As in C language, out or inout parameters should be passed by
   reference by means of the "**&**" operator before the parameter name.

#. Synchronization on a parameter can be done calling the
   **compss_wait_on** binding function. The argument of this function
   must be the variable or object we want to synchronize.

#. There is an **implicit synchronization** in the init method of
   Matrix. It is not possible to know the address of "A" before exiting
   the method call and due to this it is necessary to synchronize before
   for the copy of the returned value into "A" for it to be correct.

#. A call to the **compss_off** binding function is required to turn
   off the COMPSs runtime.

.. rubric:: Functions file

The implementation of the tasks in a C or C++ program has to be provided
in a functions file. Its name must be the same as the main file followed
by the suffix "-functions". In our case Matmul-functions.cc.

.. code-block:: C

    #include "Matmul.h"
    #include "Matrix.h"
    #include "Block.h"

    void initMatrix(Matrix *matrix,int mSize,int nSize,double val){
         *matrix = Matrix::init(mSize, nSize, val);
    }

    void multiplyBlocks(Block *block1,Block *block2,Block *block3){
         block1->multiply(*block2, *block3);
    }

In the previous code, class methods have been encapsulated inside a
function. This is useful when the class method returns an object or a
value and we want to avoid the explicit synchronization when returning
from the method.

.. rubric:: Additional source files

Other source files needed by the user application must be placed under
the directory "**src**". In this directory the programmer must provide a
**Makefile** that compiles such source files in the proper way. When the
binding compiles the whole application it will enter into the src
directory and execute the Makefile.

It generates two libraries, one for the master application and another
for the worker application. The directive COMPSS_MASTER or
COMPSS_WORKER must be used in order to compile the source files for
each type of library. Both libraries will be copied into the lib
directory where the binding will look for them when generating the
master and worker applications.
