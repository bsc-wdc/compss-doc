.. |qpybrr| raw:: html

   <br />

.. spelling:word-list::

   ab
   cd
   ef
   gh
   abcd
   efgh


Let's write your first R application parallelized with PyCOMPSs. |qpybrr|
Consider the following code:

.. code-block:: r
      :caption: ``add.R``

      add <- function(x, y) {
         return(x + y)
      }


.. code-block:: r
      :caption: ``addition.R``

      library(RCOMPSs)
      source("add.R")
      compss_start()

      add.t <- task(add, "add.R", info_only = FALSE, return_value = TRUE)

      a <- 2; b <- 3;
      c <- 4; d <- 5;
      e <- 6; f <- 7;
      g <- 8; h <- 9;

      # Task (1) a + b
      ab <- add.t(a, b)
      # Task (2) c + d
      cd <- add.t(c, d)
      # Task (3) e + f
      ef <- add.t(e, f)
      # Task (4) g + h
      gh <- add.t(g, h)

      # Task (5) ab + cd
      abcd <- add.t(ab, cd)
      # Task (6) ef + gh
      efgh <- add.t(ef, gh)

      # Task (7) abcd + efgh
      result <- add.t(abcd, efgh)

      # Retrieve the result
      result <- compss_wait_on(result)
      cat("The result is:", result, "\n")

      compss_stop()


This code uses the ``add`` function described in the ``add.R`` file to add:|qpybrr|
  - ``a`` and ``b`` into ``ab``
  - ``c`` and ``d`` into ``cd``
  - ``e`` and ``f`` into ``ef``
  - ``g`` and ``h`` into ``gh``
Then adds these partial results:|qpybrr|
  - ``ab`` and ``cd`` into ``abcd``
  - ``ef`` and ``gh`` into ``efgh``
And finally adds these partial results to achieve the final result:|qpybrr|
  - ``abcd`` and ``efgh`` into ``result``

On a normal R execution, each addition will be done after the other
(sequentially), accumulating the computational time. |qpybrr|
RCOMPSs is able to parallelize this code thanks to its ``task``
decorator which wraps the ``add`` function instantiating the
``add.t`` function, and synchronize the results with the
``compss_wait_on`` API call.

.. NOTE::

    If you are using the PyCOMPSs CLI (`pycompss-cli <https://pypi.org/project/pycompss-cli/>`_),
    it is time to deploy the COMPSs environment within your current folder:

    .. code-block:: console

            $ pycompss init

    Please, be aware that the first time needs to download the docker image from the
    repository, and it may take a while.

*Copy and paste the addition code it into* ``addition.R`` *and
add code into* ``add.R``.

.. rubric:: Execution

Now let's execute ``addition.R``. To this end, we will use the
``runcompss`` script provided by COMPSs:

.. code-block:: console

    $ runcompss --lang=r -g addition.R
      [Output in next step]

Or alternatively, the ``pycompss run`` command if using the PyCOMPSs CLI
(which wraps the ``runcompss`` command and launches it within the COMPSs' docker
container):

.. code-block:: console

    $ pycompss run --lang=r -g addition.R
      [Output in next step]

.. note::
    The ``--lang=r`` flag indicates that the application is written in R.

    The ``-g`` flag enables the task dependency graph generation (*used later*).

    The ``runcompss`` command has a lot of supported options that can be checked with the ``-h`` flag.
    They can also be used within the ``pycompss run`` command.

.. rubric:: Output

.. code-block:: console

    $ runcompss --lang=r -g addition.R
      [  INFO] Inferred PYTHON language
      [  INFO] Using default location for project file: /opt/COMPSs/Runtime/configuration/xml/projects/default_project.xml
      [  INFO] Using default location for resources file: /opt/COMPSs/Runtime/configuration/xml/resources/default_resources.xml
      [  INFO] Using default execution type: compss

      ----------------- Executing addition.R --------------------------

      WARNING: COMPSs Properties file is null. Setting default values
      [(763)    API]  -  Starting COMPSs Runtime v3.3.3.post2505 (build 20250513-0839.rfcc8f551ada00b095448810eee6b34a1baca40f8)
      The result is: 44
      [(9528)    API]  -  Execution Finished

      ------------------------------------------------------------


**Nice!** it run successfully in my 8 core laptop, we have the expected output,
and RCOMPSs has been able to run the ``addition.R`` application in almost half
of the time required by the sequential execution. *What happened under the hood?*

COMPSs started a master and one worker (by default configured to execute up to four tasks at the same time)
and executed the application (offloading the tasks execution to the worker).

Let's check the task dependency graph to see the parallelism that
COMPSs has extracted and taken advantage of.

.. rubric:: Task dependency graph

COMPSs stores the generated task dependency graph within the
``$HOME/.COMPSs/<APP_NAME>_<00-99>/monitor`` directory in dot format. |qpybrr|
The generated graph is ``complete_graph.dot`` file, which can be
displayed with any dot viewer.

.. tip::

    COMPSs provides the ``compss_gengraph`` script which converts the
    given dot file into pdf.

    .. code-block:: console

        $ cd $HOME/.COMPSs/addition.R_01/monitor
        $ compss_gengraph complete_graph.dot
        $ evince complete_graph.pdf  # or use any other pdf viewer you like

    It is also available within the PyCOMPSs CLI:

    .. code-block:: console

        $ cd $HOME/.COMPSs/addition.R_01/monitor
        $ pycompss gengraph complete_graph.dot
        $ evince complete_graph.pdf  # or use any other pdf viewer you like

And you should see:

  .. figure:: /Sections/00_Quickstart/Figures/addition.png
     :alt: The dependency graph of the addition application
     :align: center
     :width: 30.0%

     The dependency graph of the addition application

COMPSs has detected that the addition of ``a+b`` and ``c+d`` is independent,
and consequently, that they can be done in parallel. While the addition
of ``res1+res2`` waits for the previous additions.

.. rubric:: Check the performance

Let's run it again with the tracing flag enabled:

.. code-block:: console

    $ runcompss -t addition.R
      [  INFO] Inferred PYTHON language
      [  INFO] Using default location for project file: /opt/COMPSs//Runtime/configuration/xml/projects/default_project.xml
      [  INFO] Using default location for resources file: /opt/COMPSs//Runtime/configuration/xml/resources/default_resources.xml
      [  INFO] Using default execution type: compss

      ----------------- Executing addition.R --------------------------

      Welcome to Extrae 3.8.3

      [... Extrae prolog ...]

      WARNING: COMPSs Properties file is null. Setting default values
      [(843)    API]  -  Starting COMPSs Runtime v3.3.3.post2505 (build 20250513-0839.rfcc8f551ada00b095448810eee6b34a1baca40f8)
      The result is: 44

      [... Extrae eplilog ...]

      mpi2prv: Congratulations! ./trace/addition.R_compss_trace.prv has been generated.
      [(24117)    API]  -  Execution Finished

      ------------------------------------------------------------

The execution has finished successfully and the trace has been generated
in the ``$HOME/.COMPSs/<APP_NAME>_<00-99>/trace`` directory in prv format,
which can be displayed and analyzed with `PARAVER <https://tools.bsc.es/paraver>`_.

.. code-block:: console

    $ cd $HOME/.COMPSs/addition.R_02/trace
    $ wxparaver addition.R_compss_trace_*.prv

.. NOTE::

    In the case of using the PyCOMPSs CLI, the trace will be generated
    in the ``.COMPSs/<APP_NAME>_<00-99>/trace`` directory:

    .. code-block:: console

        $ cd .COMPSs/addition.R_02/trace
        $ wxparaver addition.R_compss_trace.prv

Once Paraver has started, lets visualize the tasks:

- Click in ``File`` and then in ``Load Configuration``

- Look for ``$COMPSS_HOME/Dependencies/paraver/cfgs/compss_tasks.cfg`` and click ``Open``.

.. NOTE::

    In the case of using the PyCOMPSs CLI, the configuration files can be
    obtained by downloading them from the `COMPSs repository <https://github.com/bsc-wdc/compss/tree/stable/files/paraver/cfgs>`_.

And you should see:

  .. figure:: /Sections/00_Quickstart/Figures/addition_trace.png
      :alt: Trace of the addition.R application
      :align: center
      :width: 50.0%

      Trace of the addition.R application

The X axis represents the time, and the Y axis the deployed processes
(the first five (1.1.1-1.1.5) belong to the master and the next three belongs
to the master process in the worker (2.1.1-2.1.3) whose events are
shown with the ``compss_runtime.cfg`` configuration file).

The ``addition`` tasks are depicted in blue.
We can quickly see that the first four `add` tasks have been executed in parallel
(one per core), the next two as well, and finally, the last one that accumulates
all partial results at the end.

Paraver is a very powerful tool for performance analysis. For more information,
check the :ref:`Sections/04_Ecosystem/03_Tracing:|:dart:| Tracing` Section.

.. NOTE::

    If you are using the COMPSs CLI, it is time to stop the COMPSs environment:

    .. code-block:: console

            $ pycompss stop
