\section{Python Binding}
\label{sec:Python}

COMPSs features a binding for Python 2 and 3 applications. 
The next subsections explain how to program a Python application for COMPSs and a brief overview on how to execute it.

\subsection{Programming Model}
\label{subsec:Python_programming_model}

\subsubsection{Task Selection}

As in the case of Java, a COMPSs Python application is a Python sequential program that contains calls to tasks. 
In particular, the user can select as a task:

\begin{itemize}
 \item Functions
 \item Instance methods: methods invoked on objects.
 \item Class methods: static methods belonging to a class.
\end{itemize}

The task definition in Python is done by means of Python decorators instead of an annotated interface. 
In particular, the user needs to add a {\it $@$task} decorator that describes the task before the definition of the function/method.

As an example, let us assume that the application calls a function \textit{func}, which receives a file path (string parameter) 
and an integer parameter. The code of \textit{func} updates the file.

\begin{lstlisting}[language=python]
def func(file_path, value):
    # update the file 'file_path'

my_file = '/tmp/sample_file.txt'
func(my_file, 1)
\end{lstlisting}

In order to select {\it func} as a task, the corresponding {\it $@$task} decorator needs to be placed right 
before the definition of the function, providing some metadata about the parameters of that function. 
The {\it $@$task} decorator has to be imported from the {\it pycompss} library:

\begin{lstlisting}[language=python]
from pycompss.api.task import task
\end{lstlisting}

The metadata corresponding to a parameter is specified as an argument of the decorator, whose name is 
the formal parameter's name and whose value defines the type and direction of the parameter. 
The parameter types and directions can be:

\begin{itemize}
 \item Types: {\it primitive types} (integer, long, float, boolean), {\it strings}, {\it objects} (instances of user-defined classes, dictionaries, lists, tuples, complex numbers) and {\it files} are supported.
 \item Direction: it can be read-only ({\it IN} - default), read-write ({\it INOUT}), write-only ({\it OUT}) or in some cases concurrent ({\it CONCURRENT}).
\end{itemize}

COMPSs is able to automatically infer the parameter type for primitive types, strings and objects, 
while the user needs to specify it for files. On the other hand, the direction is only mandatory for 
{\it INOUT} and {\it OUT} parameters. Thus, when defining the parameter metadata in the {\it $@$task} 
decorator, the user has the following options:

\begin{itemize}
 \item {\it IN}: the parameter is read-only. The type will be inferred.
 \item {\it INOUT}: the parameter is read-write. The type will be inferred.
 \item {\it OUT}: the parameter is write-only. The type will be inferred.
 \item {\it CONCURRENT}: the parameter is read-write with concurrent acces. The type will be inferred.
 \item {\it FILE/FILE\_IN}: the parameter is a file. The direction is assumed to be {\it IN}.
 \item {\it FILE\_INOUT}: the parameter is a read-write file.
 \item {\it FILE\_OUT}: the parameter is a write-only file.
 \item {\it FILE\_CONCURRENT}: the parameter is a concurrent read-write file.
 \item {\it COLLECTION\_IN}: the parameter is read-only collection.
 \item {\it COLLECTION\_INOUT}: the parameter is read-write collection.
\end{itemize}

Consequently, please note that in the following cases there is no need to include an argument in 
the {\it $@$task} decorator for a given task parameter:

\begin{itemize}
 \item Parameters of primitive types (integer, long, float, boolean) and strings: the type of these 
       parameters can be automatically inferred by COMPSs, and their direction is always {\it IN}.
 \item Read-only object parameters: the type of the parameter is automatically inferred, and the 
       direction defaults to {\it IN}.
\end{itemize}

The parameter metadata is available from the {\it pycompss} library:

\begin{lstlisting}[language=python]
from pycompss.api.parameter import *
\end{lstlisting}
 
Continuing with the example, in the following code snippet the decorator specifies that {\it func} 
has a parameter called {\it f}, of type {\it FILE} and {\it INOUT} direction. Note how the second 
parameter, {\it i}, does not need to be specified, since its type (integer) and direction ({\it IN}) 
are automatically inferred by COMPSs.

\begin{lstlisting}[language=python]
from pycompss.api.task import task     # Import @task decorator
from pycompss.api.parameter import *   # Import parameter metadata for the @task decorator

%*{\bf @task }*)(f=FILE_INOUT)
def func(f, i):
     fd = open(f, 'r+')
     ...
\end{lstlisting}

The user can also define that the access to a parameter is concurrent with {\it CONCURRENT} or to a file {\it FILE\_CONCURRENT}.
This allows users to have access from multiple tasks to the same object/file during their executions.
Please, note that COMPSs does not manage the interaction with the objects or files used/modified concurrently.
Taking care of the access/modification of the concurrent objects is responsibility of the developer.

\begin{lstlisting}[language=python]
from pycompss.api.task import task     # Import @task decorator
from pycompss.api.parameter import *   # Import parameter metadata for the @task decorator

%*{\bf @task }*)(f=FILE_CONCURRENT)
def func(f, i):
     ...
\end{lstlisting}

Moreover, it is possible to specify that the parameter is a collection of elements (e.g. list) and its
direction (COLLECTION\_IN or COLLECTION\_INOUT). 
In this case, the list may contain sub-objects that will be handled automatically by the runtime.

\begin{lstlisting}[language=python]
from pycompss.api.task import task     # Import @task decorator
from pycompss.api.parameter import *   # Import parameter metadata for the @task decorator

%*{\bf @task }*)(my_collection=COLLECTION_IN)
def func(my_collection):
     for element in my_collection:
     ...
\end{lstlisting}

In order to improve the performance, the depth of the sub-objects can be limited through the use of the
{\it depth} parameter as:

$@task(my\_collection=\{Type: COLLECTION\_IN, Depth: 2\})$ \\

If the function or method returns a value, the programmer must use the {\it returns}  argument within
the {\it $@$task} decorator. In this argument, the programmer can specify the type of that value:

\begin{lstlisting}[language=python]
@task(%*{\bf returns }*)=int)
def ret_func():
     return 1
\end{lstlisting}

Moreover, if the function or method returns more than one value, the programmer can specify how many 
and their type in the {\it returns} argument. The next next code snippet shows how to specify that two 
values (an integer and a list) are returned:

\begin{lstlisting}[language=python]
@task(%*{\bf returns }*)=(int, list))
def ret_func():
     return 1, [2, 3]
\end{lstlisting}

Alternatively, the user can specify the number of return statements as an integer value. This way of
specifying the amount of return eases the {\it returns} definition since the user does not need to
specify explicitly the type of the return arguments. However, it must be considered that the type 
of the object returned when the task is invoked will be a future object.
This consideration may lead to an error if the user expects to invoke a task defined within an object
returned by a previous task. In this scenario, the solution is to specify explicitly the return type.

\begin{lstlisting}[language=python]
@task(%*{\bf returns }*)=1)
def ret_func():
     return "my_string"

@task(%*{\bf returns }*)=2)
def ret_func():
     return 1, [2, 3]
\end{lstlisting}

The use of {\it *args} and {\it **kwargs} as function parameters is also supported:

\begin{lstlisting}[language=python]
@task(%*{\bf returns }*)=int)
def argkwarg_func(*args, **kwargs):
    return sum(args) + len(kwargs)
\end{lstlisting}

And even with other parameters, such as usual parameters and {\it default defined arguments}. The next 
snippet shows an example of a task with two three parameters (whose one of them ({\it 's'}) has a default
value), {\it *args} and {\it **kwargs}.

\begin{lstlisting}[language=python]
@task(%*{\bf returns }*)=int)
def multiarguments_func(v, w, s = 2, *args, **kwargs):
    return (v * w) + sum(args) + len(kwargs) + s
\end{lstlisting}

For tasks corresponding to instance methods, by default the task is assumed to modify the callee object 
(the object on which the method is invoked). The programmer can tell otherwise by setting the 
{\it is\_modifier} argument of the {\it $@$task} decorator to {\it False}.

\begin{lstlisting}[language=python]
class MyClass(object):
    ...
    @task(%*{\bf is\_modifier }*) = False)
    def instance_method(self):
        ... # self is NOT modified here
\end{lstlisting}

\paragraph{Scheduler hints}

The programmer can provide hints to the scheduler through specific arguments within the {\it @task} decorator.

For instance, the programmer can mark a task as a high-priority task with the {\it priority} argument of the 
{\it $@$task} decorator. In this way, when the task is free of dependencies, it will be scheduled before 
any of the available low-priority (regular) tasks. This functionality is useful for tasks that are in 
the critical path of the applicationâ€™s task dependency graph.

\begin{lstlisting}[language=python]
@task(%*{\bf priority }*)=True)
def func():
    ...
\end{lstlisting}

Moreover, the user can also mark a task as distributed with the {\it is\_distributed} argument or as 
replicated with the {\it is\_replicated} argument. When a task is marked with {\it is\_distributed=True}, 
the method must be scheduled in a forced round robin among the available resources.
On the other hand, when a task is marked with {\it is\_replicated=True}, the method must be executed in 
all the worker nodes when invoked from the main application.
The default value for these parameters is False.

\begin{lstlisting}[language=python]
@task(%*{\bf is\_distributed }*)=True)
def func():
    ...

@task(%*{\bf is\_replicated }*)=True)
def func2():
    ...
\end{lstlisting}

Table \ref{tab:task_decorator_arguments} summarizes the arguments that can be found in the {\it $@$task} decorator.

\bgroup
  \def\arraystretch{1.5}%
  \begin{longtable}{| p{0.28\textwidth} | p{0.72\textwidth} |}
    \hline
    \multicolumn{1}{|c|}{{\bf Argument }}    &  \multicolumn{1}{c|}{{\bf Value }}\\
    \hline
    \multirow{5}{*}{Formal parameter name}  &  - IN: read-only parameter, all types. \\
    & - INOUT: read-write parameter, all types except file (primitives, strings, objects). \\
    & - OUT: read-write parameter, all types except file (primitives, strings, objects). \\
    & - FILE/FILE\_IN: read-only file parameter. \\
    & - FILE\_INOUT: read-write file parameter. \\
    & - FILE\_OUT: write-only file parameter. \\
    & - COLLECTION\_IN: read-only collection parameter (list). \\
    & - COLLECTION\_INOUT: read-write collection parameter (list). \\
    \hline
    returns & int (for integer and boolean), long, float, str, dict, list, tuple, user-defined classes \\
    \hline
    is\_modifier &  True (default) or False \\
    \hline
    priority  & True or False (default) \\
    \hline
    is\_distributed & True or False (default) \\
    \hline
    is\_replicated  & True or False (default) \\
    \hline
    \caption{Arguments of the {\it $@$task} decorator.}
    \label{tab:task_decorator_arguments}
  \end{longtable}
\egroup


\paragraph{Other task types}
\label{par:other_decorators}

In addition to this API functions, the programmer can use a set of decorators for other purposes.

For instance, there is a set of decorators that can be placed over the {\it $@$task} decorator in order to 
define the task methods as a binary invocation (with the {\it $@$binary} decorator), as a OmpSs invocation 
(with the {\it $@$ompss} decorator), as a MPI invocation (with the {\it $@$mpi} decorator), as a COMPSs application
(with the {\it $@$compss} decorator), or as a task that requires multiple nodes (with the {\it $@$multinode} decorator).
These decorators must be placed over the {\it $@$task} decorator, and under the {\it $@$constraint} decorator if 
defined.

Consequently, the task body will be empty and the function parameters will be used as invocation parameters
with some extra information that can be provided within the {\it $@$task} decorator.

The following subparagraphs describe their usage.

\subparagraph{Binary decorator}
\label{subpar:binary_decorator}

The {\it $@$binary} decorator shall be used to define that a task is going to invoke a binary executable.

In this context, the {\it $@$task} decorator parameters will be used as the binary invocation parameters
(following their order in the function definition). Since the invocation parameters can be of different nature, 
information on their type can be provided through the {\it $@$task} decorator.

The following snippet shows the most simple binary task definition without/with constraints (without parameters):

\begin{lstlisting}[language=python]
from pycompss.api.task import task
from pycompss.api.binary import binary

@binary(binary="mybinary.bin")
@task()
def binary_func():
     pass
     
@constraint(computingUnits="2")
@binary(binary="otherbinary.bin")
@task()
def binary_func2():
     pass
\end{lstlisting}

The invocation of these tasks would be equivalent to:

\begin{lstlisting}[language=bash]
./mybinary.bin 

./otherbinary.bin   # in resources that respect the constraint.
\end{lstlisting}

The following snippet shows a more complex binary invocation, with files as parameters:

\begin{lstlisting}[language=python]
from pycompss.api.task import task
from pycompss.api.binary import binary
from pycompss.api.parameter import *

@binary(binary="grep", working_dir=".")
@task(infile={Type:FILE_IN_STDIN}, result={Type:FILE_OUT_STDOUT})
def grepper():
     pass
     
# This task definition is equivalent to the folloowing, which is more verbose:

@binary(binary="grep", working_dir=".")
@task(infile={Type:FILE_IN, Stream:STDIN}, result={Type:FILE_OUT, Stream:STDOUT})
def grepper(keyword, infile, result):
     pass
     
infile = "infile.txt"
outfile = "outfile.txt"
grepper("Hi", infile, outfile)
\end{lstlisting}

The invocation of the {\it grepper} task would be equivalent to:

\begin{lstlisting}[language=bash]
# grep keyword < infile > result

grep Hi < infile.txt > outfile.txt
\end{lstlisting}

Please note that the {\it keyword} parameter is a string, and it is respected as is in the invocation call.

Thus, PyCOMPSs can also deal with prefixes for the given parameters. 
The following snippet performs a system call (ls) with specific prefixes:

\begin{lstlisting}[language=python]
from pycompss.api.task import task
from pycompss.api.binary import binary
from pycompss.api.parameter import *

@binary(binary="ls")
@task(hide={Type:FILE_IN, Prefix:"--hide="}, sort={Prefix:"--sort="})
def myLs(flag, hide, sort):
    pass
    
flag = '-l'
hideFile = "fileToHide.txt"
sort = "time"
myLs(flag, hideFile, sort)
\end{lstlisting}

The invocation of the {\it myLs} task would be equivalent to:

\begin{lstlisting}[language=bash]
# ls -l --hide=hide --sort=sort

ls -l --hide=fileToHide.txt --sort=time
\end{lstlisting}

This particular case is intended to show all the power of the {\it $@$binary} decorator in conjuntion with the
{\it $@$task} decorator. Please note that although the {\it hide} parameter is used as a prefix for the binary invocation,
the {\it fileToHide.txt} would also be transfered to the worker (if necessary) since its type is defined as FILE\_IN. 
This feature enables to build more complex binary invocations.

\subparagraph{OmpSs decorator}
\label{subpar:ompss_decorator}

The {\it $@$ompss} decorator shall be used to define that a task is going to invoke a OmpSs executable.

\begin{lstlisting}[language=python]
from pycompss.api.ompss import ompss

@ompss(binary="ompssApp.bin")
@task()
def ompss_func():
     pass
\end{lstlisting}

The OmpSs executable invocation can also be enriched with parameters, files and prefixes as with the 
{\it $@$binary} decorator through the function parameters and {\it $@$task} decorator information.
Please, check subparagraph \ref{subpar:binary_decorator} for more details.

\subparagraph{MPI decorator}
\label{subpar:mpi_decorator}

The {\it $@$mpi} decorator shall be used to define that a task is going to invoke a MPI executable.

\begin{lstlisting}[language=python]
from pycompss.api.mpi import mpi

@mpi(binary="mpiApp.bin", runner="mpirun", computing_nodes=2)
@task()
def mpi_func():
     pass
\end{lstlisting}

The MPI executable invocation can also be enriched with parameters, files and prefixes as with the 
{\it $@$binary} decorator through the function parameters and {\it $@$task} decorator information.
Please, check subparagraph \ref{subpar:binary_decorator} for more details.

\subparagraph{COMPSs decorator}
\label{subpar:compss_decorator}

The {\it $@$compss} decorator shall be used to define that a task is going to be a COMPSs application.
It enables to have nested PyCOMPSs\/COMPSs applications.

\begin{lstlisting}[language=python]
from pycompss.api.compss import compss

@compss(runcompss="${RUNCOMPSS}", flags="-d", appname="/path/to/simple_compss_nested.py", computing_nodes="2")
@task()
def compss_func():
     pass
\end{lstlisting}

The COMPSs application invocation can also be enriched with the flags accepted by the {\it runcompss} executable.
Please, check execution manual for more details about the supported flags.

\subparagraph{Multinode decorator}
\label{subpar:multinode_decorator}

The {\it $@$multinode} decorator shall be used to define that a task is going to use multiple nodes
(e.g. using internal parallelism).

\begin{lstlisting}[language=python]
from pycompss.api.multinode import multinode

@multinode(computing_nodes="2")
@task()
def multinode_func():
     pass
\end{lstlisting}

The only supported parameter is {\it computing\_nodes}, used to define the number of nodes required by the task (the default value is 1).
The mechanism to get the number of nodes, threads and their names to the task is through the {\it COMPSS\_NUM\_NODES}, {\it COMPSS\_NUM\_THREADS} and
{\it COMPSS\_HOSTNAMES} environment variables respectively, which are exported within the task scope by the COMPSs runtime before the task execution.

\subparagraph{Parameters summary}

Table \ref{tab:other_decorators} summarizes the parameters of these decorators.

\bgroup
  \def\arraystretch{1.5}%
  \begin{longtable}{| p{0.25\textwidth} | p{0.75\textwidth} |}
    \hline
    \multicolumn{1}{|c|}{{\bf Decorator }} &  \multicolumn{1}{c|}{{\bf Parameters }}\\
    \hline
        \multirow{2}{*}{{\bf $@$binary}} & {\bf binary}: (Mandatory) String defining the full path of the binary that must be executed. \\
                                         & {\bf working\_dir}: Full path of the binary working directory inside the COMPSs Worker. \\
    \hline
        \multirow{2}{*}{{\bf $@$ompss}} & {\bf binary}: (Mandatory) String defining the full path of the binary that must be executed. \\
                                        & {\bf working\_dir}: Full path of the binary working directory inside the COMPSs Worker. \\
    \hline
        \multirow{4}{*}{{\bf $@$mpi}} & {\bf binary}: (Mandatory) String defining the full path of the binary that must be executed. \\
                                      & {\bf working\_dir}: Full path of the binary working directory inside the COMPSs Worker. \\
                                      & {\bf runner}: (Mandatory) String defining the MPI runner command. \\
                                      & {\bf computing\_nodes}: Integer defining the number of computing nodes reserved for the MPI execution
                                        (only a single node is reserved by default). \\
    \hline
        \multirow{2}{*}{{\bf $@$compss}} & {\bf runcompss}: (Mandatory) String defining the full path of the runcompss binary that must be executed. \\
                                         & {\bf flags}: String defining the flags needed for the runcompss execution. \\
                                         & {\bf appname}: (Mandatory) String defining the application that must be executed. \\
                                         & {\bf computing\_nodes}: Integer defining the number of computing nodes reserved for the COMPSs execution
                                           (only a single node is reserved by default). \\
    \hline
        \multirow{2}{*}{{\bf $@$multinode}} & {\bf computing\_nodes}: Integer defining the number of computing nodes reserved for the task execution
                                              (only a single node is reserved by default). \\
    \hline
     \caption{$@$binary, $@$ompss, $@$mpi, $@$compss and $@$multinode decorators supported parameters.}
    \label{tab:other_decorators}
  \end{longtable}
\egroup

Table \ref{tab:other_parameters} summarizes the parameter key that can be used within the {\it $@$task} decorator for the 
function parameters when using these decorators.

\bgroup
  \def\arraystretch{1.5}%
  \begin{longtable}{| p{0.25\textwidth} | p{0.75\textwidth} |}
    \hline
    \multicolumn{1}{|c|}{{\bf Parameter key}} &  \multicolumn{1}{c|}{{\bf Values }}\\
    \hline
        \multirow{3}{*}{{\bf Type}} & {\bf (default: empty)}: The parameter is an object or a simple tipe that will be inferred. \\
                                    & {\bf COLLECTION}: The parameter is a collection. \\
                                    & {\bf FILE}: The parameter is a file. \\
                                    & {\bf Table \ref{tab:other_parameters_shortcuts} shortcut}: See table below.\\
    \hline
        \multirow{4}{*}{{\bf Direction}} & {\bf (default: empty)}: In direction. \\
                                         & {\bf IN}: In direction. \\
                                         & {\bf OUT}: Out direction. \\
                                         & {\bf INOUT}: In and out direction. \\
                                         & {\bf CONCURRENT}: Concurrent direction. \\
    \hline
        \multirow{4}{*}{{\bf Stream}} & {\bf (default: empty)}: Not a stream. \\
                                      & {\bf STDIN}: Standard input. \\
                                      & {\bf STDOUT}: Standard output. \\
                                      & {\bf STDERR}: Standard error. \\
    \hline
     \caption{Parameters definition for the $@$binary, $@$ompss and $@$mpi decorators}
    \label{tab:other_parameters}
  \end{longtable}
\egroup

Moreover, there are some shorcuts that can be used for files type definition as parameters within the {\it $@$task} decorator (Table \ref{tab:other_parameters_shortcuts}).
It is not necessary to indicate the {\it Direction} nor the {\it Stream} since it may be already be indicated with the shorcut.

\bgroup
  \def\arraystretch{1.5}%
  \begin{longtable}{| p{0.45\textwidth} | p{0.55\textwidth} |}
    \hline
    \multicolumn{1}{|c|}{{\bf Alias }} &  \multicolumn{1}{c|}{{\bf Description }}\\
    \hline
        \multirow{1}{*}{{\bf COLLECTION(\_IN)}}  & Type: COLLECTION, Direction: IN \\
        \multirow{1}{*}{{\bf COLLECTION\_INOUT}}  & Type: COLLECTION, Direction: INOUT \\
        \multirow{1}{*}{{\bf FILE(\_IN)\_STDIN}}  & Type: File, Direction: IN, Stream: STDIN \\
        \multirow{1}{*}{{\bf FILE(\_IN)\_STDERR}} & Type: File, Direction: IN, Stream: STDOUT \\
        \multirow{1}{*}{{\bf FILE(\_IN)\_STDOUT}} & Type: File, Direction: IN, Stream: STDERR \\
        \multirow{1}{*}{{\bf FILE\_OUT\_STDIN}}  & Type: File, Direction: OUT, Stream: STDIN \\
        \multirow{1}{*}{{\bf FILE\_OUT\_STDERR}} & Type: File, Direction: OUT, Stream: STDOUT \\
        \multirow{1}{*}{{\bf FILE\_OUT\_STDOUT}} & Type: File, Direction: OUT, Stream: STDERR \\
        \multirow{1}{*}{{\bf FILE\_INOUT\_STDIN}}  & Type: File, Direction: INOUT, Stream: STDIN \\
        \multirow{1}{*}{{\bf FILE\_INOUT\_STDERR}} & Type: File, Direction: INOUT, Stream: STDOUT \\
        \multirow{1}{*}{{\bf FILE\_INOUT\_STDOUT}} & Type: File, Direction: INOUT, Stream: STDERR \\
        \multirow{1}{*}{{\bf FILE\_CONCURRENT}}  & Type: File, Direction: CONCURRENT \\
        \multirow{1}{*}{{\bf FILE\_CONCURRENT\_STDIN}}  & Type: File, Direction: CONCURRENT, Stream: STDIN \\
        \multirow{1}{*}{{\bf FILE\_CONCURRENT\_STDERR}} & Type: File, Direction: CONCURRENT, Stream: STDOUT \\
        \multirow{1}{*}{{\bf FILE\_CONCURRENT\_STDOUT}} & Type: File, Direction: CONCURRENT, Stream: STDERR \\
    \hline
     \caption{File parameters definition shortcuts}
    \label{tab:other_parameters_shortcuts}
  \end{longtable}
\egroup

These parameter keys, as well as the shortcuts, can be imported from the PyCOMPSs library:

\begin{lstlisting}[language=python]
from pycompss.api.parameter import *
\end{lstlisting}

\subsubsection{Constraints}
\label{subsubsec:constraints}

As in Java COMPSs applications, it is possible to define constraints for each task.
To this end, the decorator {\it $@$constraint} followed by the desired constraints needs to be placed over the $@$task decorator.

\begin{lstlisting}[language=python]
from pycompss.api.task import task
from pycompss.api.constraint import constraint
from pycompss.api.parameter import INOUT

%*{\bf @constraint }*)(computing_units="4")
%*{\bf @task }*)(c=INOUT)
def func(a, b, c):
     c += a*b
     ...
\end{lstlisting}

This decorator enables the user to set the particular constraints for each task, such as the amount of Cores required explicitly.
Alternatively, it is also possible to indicate that the value of a constraint is specified in a environment variable.
A full description of the supported constraints can be found in Table \ref{tab:constraints} in Section \ref{sec:Constraints}.

For example:

\begin{lstlisting}[language=python]
from pycompss.api.task import task
from pycompss.api.constraint import constraint
from pycompss.api.parameter import INOUT

%*{\bf @constraint }*)(computing_units="4", app_software="numpy,scipy,gnuplot", memory_size="$MIN_MEM_REQ")
%*{\bf @task }*)(c=INOUT)
def func(a, b, c):
     c += a*b
     ...
\end{lstlisting}

Please, take into account that in order to respect the constraints, the peculiarities of the infrastructure must be defined in the {\it resources.xml} file.


\subsubsection{Implements}

As in Java COMPSs applications, it is possible to define multiple implementations for each task.
In particular, a programmer can define a task for a particular purpose, and multiple implementations for that task
with the same objective, but with different constraints (e.g. specific libraries, hardware, etc). 
To this end, the {\it @implement} decorator followed with the specific implementations constraints (with the 
{\it @constraint} decorator, see Section \ref{subsubsec:constraints}) needs to be placed over the $@$task decorator.
Although the user only calls the task that is not decorated with the {\it @implement} decorator, when the application 
is executed in a heterogeneous distributed environment, the runtime will take into account the constraints on each 
implementation  and will try to invoke the implementation that fulfills the constraints within each resource, 
keeping this management invisible to the user.

%As an example of this functionality, we can think on a task that performs a complicated numeric algorithm through
%Python built-in libraries, and another task that does the same complicated algorithm but using an optimized library
%for numerical operations.
%The implementation with the  will require a explicit constraint definition (see Section \ref{subsubsec:constraints}).
%Although the user calls the first task, the implementation of the task will be used on the nodes where optimized
%library is available, and the other one in the ones.

\begin{lstlisting}[language=python]
from pycompss.api.implement import implement

@implement(source_class="sourcemodule", method="main_func")
@constraint(app_software="numpy")
@task(returns=list)
def myfunctionWithNumpy(list1, list2):
    # Operate with the lists using numpy
    return resultList

@task(returns=list)
def main_func(list1, list2):
    # Operate with the lists using built-int functions
    return resultList
\end{lstlisting}

Please, note that if the implementation is used to define a binary, OmpSs, MPI, COMPSs or multinode task invocation
(see Section \ref{par:other_decorators}), the $@$implement decorator must be always on top of the decorators stack,
followed by the $@$constraint decorator, then the $@$binary/$@$ompss/$@$mpi/$@$compss/$@$multinode decorator, and finally, 
the $@$task decorator in the lowest level.

\subsubsection{Main Program}
The main program of the application is a sequential code that contains calls to the selected tasks. 
In addition, when synchronizing for task data from the main program, 
there exist four API functions that can to be invoked:

\begin{itemize}
 \item {\it compss\_open(file\_name, mode = 'r')}: similar to the Python {\it open()} call. It synchronizes
       for the last version of file {\it file\_name} and returns the file descriptor for that synchronized
       file. It can have an optional parameter {\it mode}, which defaults to '{\it r}', containing the
       mode in which the file will be opened (the open modes are analogous to those of
       Python {\it open()}).
 \item {\it compss\_delete\_file(file\_name)}: notifies the runtime to delete a file.
 \item {\it compss\_delete\_object(object)}: notifies the runtime to delete all the associated files to
 a given object.
 \item {\it compss\_wait\_on(obj, to\_write = True)}: synchronizes for the last version of object {\it obj}
       and returns the synchronized object. It can have an optional boolean parameter
       {\it to\_write}, which defaults to {\it True}, that indicates whether the main program will modify the
       returned object.       
       It is possible to wait on a list of objects. In this particular case, it will synchronize all future objects 
       contained in the list.
 \item {\it compss\_barrier()}: performs a explicit synchronization, but does not return any object. The use of {\it compss\_barrier()}
       forces to wait for all tasks that have been submitted before the {\it compss\_barrier()} is called.
       When all tasks submitted before the {\it compss\_barrier()} have finished, the execution continues.
\end{itemize}

To illustrate the use of the aforementioned API functions, the following example first invokes a task 
{\it func} that writes a file, which is later synchronized by calling {\it compss\_open()}. 
Later in the program, an object of class {\it MyClass} is created and a task method {\it method} 
that modifies the object is invoked on it; the object is then synchronized with {\it compss\_wait\_on()}, 
so that it can be used in the main program from that point on.

Then, a loop calls again ten times to {\it func} task.
Afterwards, the barrier performs a synchronization, and the execution of the main user code will
not continue until the ten {\it func} tasks have finished.

\begin{lstlisting}[language=python]
from pycompss.api.api import compss_open
from pycompss.api.api import compss_delete_file
from pycompss.api.api import compss_wait_on
from pycompss.api.api import compss_barrier

my_file = 'file.txt'
func(my_file)
fd = %*{\bf compss\_open}*)(my_file)
...

my_file2 = 'file2.txt'
func(my_file2)
fd = %*{\bf compss\_delete\_file}*)(my_file2)
...

my_obj = MyClass()
my_obj.method()
my_obj = %*{\bf compss\_wait\_on}*)(my_obj)
...

for i in range(10):
    func(str(i) + my_file)
compss_barrier()
...
\end{lstlisting}

The corresponding task selection for the example above would be:

\begin{lstlisting}[language=python]
@task(f=FILE_OUT)
def func(f):
    ...
    
class MyClass(object):
    ...
    
    @task()
    def method(self):
        ... # self is modified here
\end{lstlisting}

Table \ref{tab:python_api_functions} summarizes the API functions to be used in the main program of a COMPSs Python application.
\bgroup
  \def\arraystretch{1.5}%
  \begin{longtable}{| p{0.45\textwidth} | p{0.5\textwidth} |}
    \hline
    \multicolumn{1}{|c|}{{\bf Function }}    &  \multicolumn{1}{c|}{{\bf Use }}\\
    \hline
    compss\_open(file\_name, mode='r') & Synchronizes for the last version of a file and returns its file descriptor. \\
    \hline
    compss\_delete\_file(file\_name) & Notifies the runtime to remove a file. \\
    \hline
    compss\_delete\_object(object) & Notifies the runtime to delete the associated file to this object. \\
    \hline
    compss\_wait\_on(obj, to\_write=True) & Synchronizes for the last version of an object (or a list of objects) and returns it. \\
    \hline
    compss\_barrier() & Wait for all tasks submitted before the barrier. \\
    \hline
    \caption{COMPSs Python API functions.}
    \label{tab:python_api_functions}
  \end{longtable}
\egroup

Besides the synchronization API functions, the programmer has also a decorator for automatic function parameters synchronization 
at his disposal. The {\it $@$local} decorator can be placed over functions that are not decorated as tasks, but that may receive 
results from tasks. In this case, the {\it $@$local} decorator synchronizes the necessary parameters in order to continue with 
the function execution without the need of using explicitly the {\it compss\_wait\_on} call for each parameter.

\begin{lstlisting}[language=python]
from pycompss.api.task import task
from pycompss.api.api import compss_wait_on
from pycompss.api.parameter import INOUT
from pycompss.api.local import local

@task(%*{\bf returns }*)=list)
@task(v=INOUT)
def append_three_ones(v):
    v += [1, 1, 1]

@local
def scale_vector(v, k):
    return [k*x for x in v]

v = [1,2,3]
append_three_ones(v)
# %*{\bf v }*) is automatically synchronized when calling the scale_vector function.
w = scale_vector(v, 2)

\end{lstlisting}


\subsubsection{Important Notes}

If the programmer selects as a task a function or method that returns a value, that value is not 
generated until the task executes. 

\begin{lstlisting}[language=python]
@task(%*{\bf returns }*)=MyClass)
def ret_func():
    return MyClass(...)

...

# %*{\bf o }*) is a future object
o = ret_func()
\end{lstlisting}

The object returned can be involved in a subsequent task call, and the COMPSs runtime will automatically 
find the corresponding data dependency. In the following example, the object \textit{o} is passed as a parameter 
and callee of two subsequent (asynchronous) tasks, respectively:

\begin{lstlisting}[language=python]
# %*{\bf o }*) is a future object
o = ret_func()

...

another_task(o)

...

o.yet_another_task()
\end{lstlisting}

In order to synchronize the object from the main program, the programmer has to synchronize (using the \textit{compss\_wait\_on} function) in the same way 
as with any object updated by a task:

\begin{lstlisting}[language=python]
# %*{\bf o }*) is a future object
o = ret_func()

...

o = compss_wait_on(o)
\end{lstlisting}
                         
Moreover, it is possible to synchronize a list of objects. This is particularly useful when the programmer expect to synchronize more 
than one elements (using the \textit{compss\_wait\_on} function):

\begin{lstlisting}[language=python]
# %*{\bf l }*) is a list of objects where some/all of them may be future objects
l = []
for i in range(10):
    l.append(ret_func())

...

l = compss_wait_on(l)
\end{lstlisting}
                         
                         
For instances of user-defined classes, the classes of these objects 
should have an empty constructor, otherwise the programmer will not be able to invoke task instance 
methods on those objects:
                                   
\begin{lstlisting}[language=python]
class MyClass(object):
    def __init__(self): # empty constructor
        ...
        
    ...

o = ret_func()

# invoking a task instance method on a future object can only
# be done when an empty constructor is defined in the object's
# class
o.yet_another_task()
\end{lstlisting}

In order to make the COMPSs Python binding function correctly, the programmer should not use relative imports in the code.
Relative imports can lead to ambiguous code and they are discouraged in Python, as explained in:

\begin{lstlisting}[language=html]
http://docs.python.org/2/faq/programming.html#what-are-the-best-practices-for-using-import-in-a-module
\end{lstlisting}


\subsection{Application Execution}
The next subsections describe how to execute applications with the COMPSs Python binding.

\subsubsection{Environment}
The following environment variables must be defined before executing a COMPSs Python application:

JAVA\_HOME: Java JDK installation directory (e.g. \textit{/usr/lib/jvm/java-8-openjdk/})

\subsubsection{Command}
In order to run a Python application with COMPSs, the runcompss script can be used, like for 
Java and C/C++ applications. An example of an invocation of the script is:

\begin{lstlisting}[language=bash]
compss@bsc:~$ runcompss \
                --lang=python \
                --pythonpath=$TEST_DIR \
                --library_path=/home/user/libdir \
                $TEST_DIR/test.py arg1 arg2
\end{lstlisting}

Or alternatively, use the \verb|pycompss| module:

\begin{lstlisting}[language=bash]
compss@bsc:~$ python -m pycompss \
                --pythonpath=$TEST_DIR \
                --library_path=/home/user/libdir \
                $TEST_DIR/test.py arg1 arg2
\end{lstlisting}

For full description about the options available for the runcompss command please check the \textit{COMPSs User Manual: Application
Execution} available at \url{http://compss.bsc.es}. 

\subsection{Development with Jupyter notebook}

PyCOMPSs can also be used within Jupyter notebooks. 
This feature allows users to develop and run their PyCOMPSs applications in a Jupyter notebook, where it is possible to modify the code during the execution and experience an interactive behaviour.

\subsubsection{Environment}
The following libraries must be present in the appropiate environment variables in order to enable PyCOMPSs within Jupyter notebook:

PYTHONPATH: The path where PyCOMPSs is installed (e.g. \textit{/opt/COMPSs/Bindings/python/})

LD\_LIBRARY\_PATH: The path where the {\it libbindings-commons.so} library is located (e.g. \textit{/opt/COMPSs/Bindings/bindings-common/lib/}) and the path where the {\it libjvm.so} library is located (e.g. \textit{/usr/lib/jvm/java-8-openjdk/jre/lib/amd64/server/}).

\subsubsection{API calls}

In this case, the user is responsible of starting and stopping the COMPSs runtime.
To this end, PyCOMPSs provides a module that provides two API calls: one for starting the COMPSs runtime, and another for stopping it.

This module can be imported from the {\it pycompss} library:

\begin{lstlisting}[language=python]
import pycompss.interactive as ipycompss
\end{lstlisting}

And contains two main functions: {\it start} and {\it stop}. These functions can then be invoked as follows for the COMPSs runtime deployment with default parameters:

\begin{lstlisting}[language=python]
# Previous user code

ipycompss.start()

# User code that can benefit from PyCOMPSs

ipycompss.stop()

# Subsequent code
\end{lstlisting}

Between the {\it start} and {\it stop} function calls, the user can write its own python code including PyCOMPSs imports, decorators and synchronization calls described in Section \ref{subsec:Python_programming_model}.
The code can be splitted into multiple cells.

The {\it start} and {\it stop} functions accept parameters in order to customize the COMPSs runtime (such as the flags that can be selected with the ``runcompss'' command).
Table \ref{tab:python_api_jupyter_start} summarizes the accepted parameters of the {\it start} function.
Table \ref{tab:python_api_jupyter_stop} summarizes the accepted parameters of the {\it stop} function.

\bgroup
  \def\arraystretch{1.5}%
  \begin{longtable}{| p{0.15\textwidth} | p{0.15\textwidth} | p{0.65\textwidth} |}
    \hline
    \multicolumn{1}{|c|}{{\bf Parameter}} & \multicolumn{1}{c|}{{\bf Parameter}} & \multicolumn{1}{c|}{\multirow{2}{*}{{\bf Description}}}\\
    \multicolumn{1}{|c|}{{\bf Name}}      & \multicolumn{1}{c|}{{\bf Type}} & \\
    \hline
    log\_level     & String  & \footnotesize{PyCOMPSs log level. Options: ``off'', ``info'' and ``debug''.\newline (Default: ``off'')} \\
    \hline
    o\_c           & Boolean & \footnotesize{Object conversion to string when possible (Default: False)} \\
    \hline
    debug          & Boolean & \footnotesize{COMPSs runtime debug (Default: False)} \\
    \hline
    graph          & Boolean & \footnotesize{Task dependency graph generation (Default: False)} \\
    \hline
    trace          & Boolean & \footnotesize{Paraver trace generation (Default: False)} \\
    \hline
    monitor        & Integer & \footnotesize{Monitor refresh rate (Default: None - Monitoring disabled)} \\ 
    \hline
    project\_xml   & String  & \footnotesize{Path to the project XML file (Default: \$COMPSS/Runtime/configuration/xml/projects/default\_project.xml)} \\ 
    \hline
    resources\_xml & String  & \footnotesize{Path to the resources XML file (Default: \$COMPSs/Runtime/configuration/xml/resources/default\_resources.xml)} \\ 
    \hline
    summary        & Boolean & \footnotesize{Show summary at the end of the execution (Default: False)} \\ 
    \hline
    storageConf    & String  & \footnotesize{Storage configuration file path (Default: None)} \\ 
    \hline
    taskCount      & Integer & \footnotesize{Number of task definitions (Default: 50)} \\ 
    \hline
    appName        & String  & \footnotesize{Application name (Default: ``Interactive'')} \\ 
    \hline
    uuid           & String  & \footnotesize{Application uuid (Default: None - Will be random)} \\ 
    \hline
    baseLogDir     & String  & \footnotesize{Base directory to store COMPSs log files (a .COMPSs/ folder will be created inside this location) (Default: User homeBase log path)} \\ 
    \hline
    specificLogDir & String  & \footnotesize{Use a specific directory to store COMPSs log files (the folder MUST exist and no sandbox is created) (Default: Disabled)} \\
    \hline
    extraeCfg      & String  & \footnotesize{Sets a custom extrae config file. Must be in a shared disk between all COMPSs workers (Default: None)} \\ 
    \hline
    comm           & String  & \footnotesize{Class that implements the adaptor for communications. Supported adaptors: ``es.bsc.compss.nio.master.NIOAdaptor'' and ``es.bsc.compss.gat.master.GATAdaptor'' (Default: ``es.bsc.compss.nio.master.NIOAdaptor'')} \\ 
    \hline
    conn           & String  & \footnotesize{Class that implements the runtime connector for the cloud. Supported connectors: ``es.bsc.compss.connectors.DefaultSSHConnector'' and ``es.bsc.compss.connectors.DefaultNoSSHConnector'' (Default: es.bsc.compss.connectors.DefaultSSHConnector)} \\ 
    \hline
    MasterName     & String  & \footnotesize{Hostname of the node to run the COMPSs master (Default: ``'')}\\ 
    \hline
    MasterPort     & String  & \footnotesize{Port to run the COMPSs master communications. Only for NIO adaptor (Default: ``[43000,44000]'')} \\ 
    \hline
    scheduler      & String  & \footnotesize{Class that implements the Scheduler for COMPSs. Supported schedulers:\newline ``es.bsc.compss.scheduler.fullGraphScheduler.FullGraphScheduler'', ``es.bsc.compss.scheduler.fifoScheduler.FIFOScheduler'' and ``es.bsc.compss.scheduler.resourceEmptyScheduler.\newline ResourceEmptyScheduler''\newline (Default: ``es.bsc.compss.scheduler.loadBalancingScheduler.\newline LoadBalancingScheduler'')} \\ 
    \hline
    jvmWorkers     & String  & \footnotesize{Extra options for the COMPSs Workers JVMs. Each option separed by "," and without blank spaces (Default: ``-Xms1024m,-Xmx1024m,-Xmn400m'')} \\ 
    \hline
    cpuAffinity    & String  & \footnotesize{Sets the CPU affinity for the workers. Supported options: ``disabled'', ``automatic'', user defined map of the form ``0-8/9,10,11/12-14,15,16'' (Default: ``automatic'')} \\ 
    \hline
    gpuAffinity    & String  & \footnotesize{Sets the GPU affinity for the workers. Supported options: ``disabled'', ``automatic'', user defined map of the form ``0-8/9,10,11/12-14,15,16'' (Default: ``automatic'')} \\ 
    \hline
    profileInput   & String  & \footnotesize{Path to the file which stores the input application profile (Default: ``'')} \\ 
    \hline
    profileOutput  & String  & \footnotesize{Path to the file to store the application profile at the end of the execution (Default: ``'')} \\ 
    \hline
    verbose        & Boolean & \footnotesize{Verbose mode (Default: False)} \\ 
    \hline
    \caption{PyCOMPSs start function for Jupyter notebook}
    \label{tab:python_api_jupyter_start}
  \end{longtable}
\egroup

\bgroup
  \def\arraystretch{1.5}%
  \begin{longtable}{| p{0.15\textwidth} | p{0.15\textwidth} | p{0.65\textwidth} |}
    \hline
    \multicolumn{1}{|c|}{{\bf Parameter}} & \multicolumn{1}{c|}{{\bf Parameter}} & \multicolumn{1}{c|}{\multirow{2}{*}{{\bf Description}}}\\
    \multicolumn{1}{|c|}{{\bf Name}}      & \multicolumn{1}{c|}{{\bf Type}} & \\
    \hline
    sync           & Boolean & \footnotesize{Synchronize the objects left on the user scope. (Default: False)} \\
    \hline
    \caption{PyCOMPSs stop function for Jupyter notebook}
    \label{tab:python_api_jupyter_stop}
  \end{longtable}
\egroup

The following code snippet shows how to start a COMPSs runtime with tracing and graph generation enabled (with {\it trace} and {\it graph} parameters), as well as enabling the monitor with a refresh rate of 2 seconds (with the {\it monitor} parameter).
It also synchronizes all remaining objects in the scope with the {\it sync} parameter when invoking the {\it stop} function.

\begin{lstlisting}[language=python]
# Previous user code

ipycompss.start(graph=True, trace=True, monitor=2000)

# User code that can benefit from PyCOMPSs

ipycompss.stop(sync=True)

# Subsequent code
\end{lstlisting}

\subsubsection{Application execution}

The application can be executed as a common Jupyter notebook by steps or the whole application.

Please, note that once the COMPSs runtime has been stopped it is necessary to restart the python kernel in Jupyter before starting another COMPSs runtime.
To this end, click on ``Kernel'' and ``Restart'' (or ``Restart \& Clear Output'' or ``Restart \& Run All'', depending on the need).