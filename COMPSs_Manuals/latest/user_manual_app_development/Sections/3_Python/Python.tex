\section{Python Binding}
\label{sec:Python}

COMPSs features a binding for Python 2.x applications. The next subsections explain how to program a Python 
application for COMPSs and how to configure the binding library.

\subsection{Programming Model}

\subsubsection{Task Selection}

As in the case of Java, a COMPSs Python application is a sequential program that contains calls 
to tasks. In particular, the user can select as a task:

\begin{itemize}
 \item Functions
 \item Instance methods: methods invoked on objects.
 \item Class methods: static methods belonging to a class.
\end{itemize}

The task definition in Python is done by means of Python decorators instead of an annotated interface. In particular, the user needs to add, before the definition of the function/method, 
a $@$task decorator that describes the task.

As an example, let us assume that the application calls a function \textit{func}, which receives a string parameter 
containing a file name and an integer parameter. The code of \textit{func} updates the file.

\begin{lstlisting}[language=python]
my_file = 'sample_file.txt'
func(my_file, 1)
\end{lstlisting}

In order to select {\it func} as a task, the corresponding {\it $@$task} decorator needs to be placed right 
before the definition of the function, providing some metadata about the parameters of that function. 
The metadata corresponding to a parameter is specified as an argument of the decorator, whose name is 
the formal parameter’s name and whose value defines the type and direction of the parameter. 
The parameter types and directions can be:

\begin{itemize}
 \item Types: {\it primitive types} (integer, long, float, boolean), {\it strings}, {\it objects} (instances of user-defined classes, dictionaries, lists, tuples, complex numbers) and {\it files} are supported.
 \item Direction: it can be read-only ({\it IN} - default), read-write ({\it INOUT}) or write-only ({\it OUT}).
\end{itemize}

COMPSs is able to automatically infer the parameter type for primitive types, strings and objects, 
while the user needs to specify it for files. On the other hand, the direction is only mandatory for 
{\it INOUT} and {\it OUT} parameters. Thus, when defining the parameter metadata in the {\it $@$task} 
decorator, the user has the following options:

\begin{itemize}
 \item {\it INOUT}: the parameter is read-write. The type will be inferred.
 \item {\it OUT}: the parameter is write-only. The type will be inferred.
 \item {\it FILE}: the parameter is a file. The direction is assumed to be {\it IN}.
 \item {\it FILE\_INOUT}: the parameter is a read-write file.
 \item {\it FILE\_OUT}: the parameter is a write-only file.
\end{itemize}
     
Consequently, please note that in the following cases there is no need to include an argument in 
the {\it $@$task} decorator for a given task parameter:

\begin{itemize}
 \item Parameters of primitive types (integer, long, float, boolean) and strings: the type of these 
       parameters can be automatically inferred by COMPSs, and their direction is always {\it IN}.
 \item Read-only object parameters: the type of the parameter is automatically inferred, and the 
       direction defaults to {\it IN}.
\end{itemize}
 
Continuing with the example, in the following code snippet the decorator specifies that {\it func} 
has a parameter called {\it f}, of type {\it FILE} and {\it INOUT} direction. Note how the second 
parameter, {\it i}, does not need to be specified, since its type (integer) and direction ({\it IN}) 
are automatically inferred by COMPSs.

\begin{lstlisting}[language=python]
from pycompss.api.task import task
from pycompss.api.parameter import *
%*{\bf @task }*)(f = FILE_INOUT)
def func(f, i):
     fd = open(f, 'r+')
     ...
\end{lstlisting}

If the function or method returns a value, the programmer must specify the type of that value using 
the {\it returns} argument of the {\it $@$task} decorator:

\begin{lstlisting}[language=python]
@task(%*{\bf returns }*) = int)
def ret_func():
     return 1
\end{lstlisting}

For tasks corresponding to instance methods, by default the task is assumed to modify the callee object 
(the object on which the method is invoked). The programmer can tell otherwise by setting the 
{\it isModifier} argument of the {\it $@$task} decorator to {\it False}.

\begin{lstlisting}[language=python]
class MyClass(object):
    ...
    @task(%*{\bf isModifier }*) = False)
    def instance_method(self):
        ... # self is NOT modified here
\end{lstlisting}

The programmer can also mark a task as a high-priority task with the {\it priority} argument of the 
{\it $@$task} decorator. In this way, when the task is free of dependencies, it will be scheduled before 
any of the available low-priority (regular) tasks. This functionality is useful for tasks that are in 
the critical path of the application’s task dependency graph.

\begin{lstlisting}[language=python]
@task(%*{\bf priority }*) = True)
def func():
    ...
\end{lstlisting}

Table \ref{tab:task_decorator_arguments} summarizes the arguments that can be found in the $@$task decorator.
\bgroup
  \def\arraystretch{1.5}%
  \begin{longtable}{| p{0.31\textwidth} | p{0.69\textwidth} |}
    \hline
    \multicolumn{1}{|c|}{{\bf Argument }}    &  \multicolumn{1}{c|}{{\bf Value }}\\
    \hline
    \multirow{5}{*}{Formal parameter name}  &  - INOUT: read-write parameter, all types except file (primitives, strings, objects). \\
    & - OUT: read-write parameter, all types except file (primitives, strings, objects). \\
    & - FILE: read-only file parameter. \\
    & - FILE\_INOUT: read-write file parameter. \\
    & - FILE\_OUT: write-only file parameter. \\
    \hline
    returns & int (for integer and boolean), long, float, str, dict, list, tuple, user-defined classes \\
    \hline
    isModifier &  True (default) or False \\
    \hline
    priority  & True or False (default) \\
    \hline
    \caption{Arguments of the {\it $@$task} decorator.}
    \label{tab:task_decorator_arguments}
  \end{longtable}
\egroup


\subsubsection{Constraints}

As in Java COMPSs applications, it is possible to define constraints for each task.
To this end, the decorator {\it $@$Constraint} followed by the desired constraints needs to be placed over the $@$Task decorator.

\begin{lstlisting}[language=python]
from pycompss.api.task import task
from pycompss.api.constraint import constraint
from pycompss.api.parameter import INOUT

%*{\bf @constraint }*)(ProcessorCoreCount=4)
%*{\bf @task }*)(c = INOUT)
def func(a, b, c):
     c += a*b
     ...
\end{lstlisting}

This decorator enables the user to set the particular constraints for each task, such as the amount of Cores required.

Table \ref{tab:python_constraints} summarizes the constraints that can be used in the $@$constraint decorator.
\bgroup
  \def\arraystretch{1.5}%
  \begin{longtable}{| p{0.3\textwidth} | p{0.1\textwidth} | p{0.55\textwidth} |}
    \hline
    \multicolumn{1}{|c|}{{\bf Argument }}   &  \multicolumn{1}{c|}{{\bf Value }} & \multicolumn{1}{c|}{{\bf Description }} \\
    \hline
    ProcessorArch & $<$string$>$ & Processor architecture (e.g. x86\_64) \\
    \hline
    ProcessorCPUCount & $<$int$>$ & Number of CPUs \\
    \hline
    ProcessorCoreCount  & $<$int$>$ & Number of Cores \\
    \hline
    ProcessorSpeed  & $<$float$>$ & Minimum processor frequency in MHz \\
    \hline
    MemoryPhysicalSize  & $<$float$>$ & Main memory in Mbs \\
    \hline
    MemoryVirtualSize  & $<$float$>$ & Virtual memory in Mbs \\
    \hline
    MemoryAccessTime  & $<$float$>$ & Main memory access time in ms \\
    \hline
    MemorySTR  & $<$float$>$ &  \\
    \hline
    StorageElemSize  & $<$float$>$ & Main storage in Mbs \\
    \hline
    StorageElemAccessTime  & $<$float$>$ & Main storage access time in ms \\
    \hline
    StorageElemSTR  & $<$float$>$ &  \\
    \hline
    OperatingSystemType  & $<$string$>$ & Operating system type (e.g. linux) \\
    \hline
    \cellcolor{blue!25} HostQueue  & $<$string$>$ &  \\
    \hline
    \cellcolor{blue!25} AppSoftware  & $<$string$>$ & Software applications that must be available within the remote node for the task \\
    \hline
    \caption{Arguments of the {\it $@$constraint} decorator.}
    \label{tab:python_constraints}
  \end{longtable}
\egroup

All constraints are defined with a simple value except the {\it HostQueue} and {\it AppSoftware} constraints, which allow multiple values.
For example:

\begin{lstlisting}[language=python]
from pycompss.api.task import task
from pycompss.api.constraint import constraint
from pycompss.api.parameter import INOUT

%*{\bf @constraint }*)(ProcessorCoreCount=4, AppSoftware="numpy,scipy,gnuplot")
%*{\bf @task }*)(c = INOUT)
def func(a, b, c):
     c += a*b
     ...
\end{lstlisting}

Please, take into account that in order to respect the constraints, the peculiarities of the infrastructure must be defined in the {\it resources.xml} file.


\subsubsection{Main Program}
The main program of the application is a sequential code that contains calls to the selected tasks. 
In addition, when synchronizing for task data from the main program, 
there exist two API functions that need to be invoked:

\begin{itemize}
 \item {\it compss\_open(file\_name, mode = 'r')}: similar to the Python {\it open()} call. It synchronizes
       for the last version of file {\it file\_name} and returns the file descriptor for that synchronized
       file. It can have an optional parameter {\it mode}, which defaults to '{\it r}', containing the
       mode in which the file will be opened (the open modes are analogous to those of
       Python {\it open()}).
 \item {\it compss\_wait\_on(obj, to\_write = True)}: synchronizes for the last version of object {\it obj}
       and returns the synchronized object. It can have an optional boolean parameter
       {\it to\_write}, which defaults to {\it True}, that indicates whether the main program will modify the
       returned object.
\end{itemize}

To illustrate the use of the aforementioned API functions, the following example first invokes a task 
{\it func} that writes a file, which is later synchronized by calling {\it compss\_open()}. 
Later in the program, an object of class {\it MyClass} is created and a task method {\it method} 
that modifies the object is invoked on it; the object is then synchronized with {\it compss\_wait\_on()}, 
so that it can be used in the main program from that point on.

\begin{lstlisting}[language=python]
from pycompss.api.api import compss_open, compss_wait_on

my_file = 'file.txt'
func(my_file)
fd = %*{\bf compss\_open}*)(my_file)
...

my_obj = MyClass()
my_obj.method()
my_obj = %*{\bf compss\_wait\_on}*)(my_obj)
...
\end{lstlisting}

The corresponding task selection for the example above would be:

\begin{lstlisting}[language=python]
@task(f = FILE_OUT)
def func(f):
    ...
    
    class MyClass(object):
        ...
        
        @task()
        def method(self):
            ... # self is modified here
\end{lstlisting}

Table \ref{tab:python_api_functions} summarizes the API functions to be used in the main program of a COMPSs Python application.
\bgroup
  \def\arraystretch{1.5}%
  \begin{longtable}{| p{0.45\textwidth} | p{0.5\textwidth} |}
    \hline
    \multicolumn{1}{|c|}{{\bf Function }}    &  \multicolumn{1}{c|}{{\bf Use }}\\
    \hline
    compss\_open(file\_name, mode = 'r') & Synchronizes for the last version of a file and returns its file descriptor. \\
    \hline
    compss\_wait\_on(obj, to\_write = True) & Synchronizes for the last version of an object and returns it. \\
    \hline
    \caption{COMPSs Python API functions.}
    \label{tab:python_api_functions}
  \end{longtable}
\egroup

\subsubsection{Important Notes}

If the programmer selects as a task a function or method that returns a value, that value is not 
generated until the task executes. 

\begin{lstlisting}[language=python]
@task(%*{\bf returns }*) = MyClass)
def ret_func():
    return MyClass(...)

...

# %*{\bf o }*) is a future object
o = ret_func()
\end{lstlisting}

The object returned can be involved in a subsequent task call, and the COMPSs runtime will automatically 
find the corresponding data dependency. In the following example, the object \textit{o} is passed as a parameter 
and callee of two subsequent (asynchronous) tasks, respectively:

\begin{lstlisting}[language=python]
# %*{\bf o }*) is a future object
o = ret_func()

...

another_task(o)

...

o.yet_another_task()
\end{lstlisting}

In order to synchronize the object from the main program, the programmer has to synchronize (using the \textit{compss\_wait\_on} function) in the same way 
as with any object updated by a task, :

\begin{lstlisting}[language=python]
# %*{\bf o }*) is a future object
o = ret_func()

...

o = compss_wait_on(o)
\end{lstlisting}
                         

For instances of user-defined classes, the classes of these objects 
should have an empty constructor, otherwise the programmer will not be able to invoke task instance 
methods on those objects:
                                   
\begin{lstlisting}[language=python]
class MyClass(object):
    def __init__(self): # empty constructor
        ...
        
    ...

o = ret_func()

# invoking a task instance method on a future object can only
# be done when an empty constructor is defined in the object's
# class
o.yet_another_task()
\end{lstlisting}

In order to make the COMPSs Python binding function correctly, the programmer should not use relative imports 
in the code. Relative imports can lead to ambiguous code and they are discouraged in Python, as explained in:

\begin{lstlisting}[language=html]
http://docs.python.org/2/faq/programming.html#what-are-the-best-practices-for-using-import-in-a-module
\end{lstlisting}


\subsection{Application Execution}
The next subsections describe how to execute applications with the COMPSs Python binding.

\subsubsection{Environment}
The following environment variables must be defined before executing a COMPSs Python application:

JAVA\_HOME: Java JDK installation directory (e.g. \textit{/usr/lib/jvm/java-7-openjdk/})

\subsubsection{Command}
In order to run a Python application with COMPSs, the runcompss script can be used, like for 
Java and C/C++ applications. An example of an invocation of the script is:

\begin{lstlisting}[language=bash]
compss@bsc:~$ runcompss \
                --lang=python \
                --classpath=$TEST_DIR \
                --library_path=/home/user/libdir \
                $TEST_DIR/test.py arg1 arg2
\end{lstlisting}

For full description about the options available for the runcompss command please check the \textit{COMPSs User Manual: Application
Execution} available at \url{http://compss.bsc.es} . 
