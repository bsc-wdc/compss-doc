\section{Python Binding}
\label{sec:Python}

COMPSs features a binding for Python 2.x applications. The next subsections explain how to program a Python 
application for COMPSs and how to configure the binding library.

\subsection{Programming Model}

\subsubsection{Task Selection}

Like in the case of the Java language, a COMPSs Python application is a sequential program that contains calls 
to tasks. In particular, the user can select as a task:

\begin{itemize}
 \item Functions
 \item Instance methods: methods invoked on objects.
 \item Class methods: static methods belonging to a class.
\end{itemize}

Regarding task selection, in Python it is not done by means of an annotated interface but with the use of 
Python decorators. In particular, the user needs to add, before the definition of the function/method, 
a $@$task decorator that describes the task.

As an example, let us assume that the application calls a function func, which receives a string parameter 
containing a file name and an integer parameter. The code of func updates the file.

\begin{lstlisting}[language=python]
my_file = 'sample_file.txt'
func(my_file, 1)
\end{lstlisting}

In order to select {\it func} as a task, the corresponding {\it $@$task} decorator needs to be placed right 
before the definition of the function, providing some metadata about the parameters of that function. 
The metadata corresponding to a parameter is specified as an argument of the decorator, whose name is 
the formal parameter’s name and whose value defines the type and direction of the parameter. 
The parameter types and directions can be:

\begin{itemize}
 \item Types: {\it primitive types} (integer, long, float, boolean), {\it strings}, {\it objects} (instances of user-defined classes, dictionaries, lists, tuples, complex numbers) and {\it files} are supported.
 \item Direction: it can be read-only ({\it IN} - default), read-write ({\it INOUT}) or write-only ({\it OUT}).
\end{itemize}

COMPSs is able to automatically infer the parameter type for primitive types, strings and objects, 
while the user needs to specify it for files. On the other hand, the direction is only mandatory for 
{\it INOUT} and {\it OUT} parameters. Thus, when defining the parameter metadata in the {\it $@$task} 
decorator, the user has the following options:

\begin{itemize}
 \item {\it INOUT}: the parameter is read-write. The type will be inferred.
 \item {\it OUT}: the parameter is write-only. The type will be inferred.
 \item {\it FILE}: the parameter is a file. The direction is assumed to be {\it IN}.
 \item {\it FILE\_INOUT}: the parameter is a read-write file.
 \item {\it FILE\_OUT}: the parameter is a write-only file.
\end{itemize}
     
Consequently, please note that in the following cases there is no need to include an argument in 
the {\it $@$task} decorator for a given task parameter:

\begin{itemize}
 \item Parameters of primitive types (integer, long, float, boolean) and strings: the type of these 
       parameters can be automatically inferred by COMPSs, and their direction is always {\it IN}.
 \item Read-only object parameters: the type of the parameter is automatically inferred, and the 
       direction defaults to {\it IN}.
\end{itemize}
 
Continuing with the example, in the following code snippet the decorator specifies that {\it func} 
has a parameter called {\it fi}, of type {\it FILE} and {\it INOUT} direction. Note how the second 
parameter, {\it i}, does not need to be specified, since its type (integer) and direction ({\it IN}) 
are automatically inferred by COMPSs.

\begin{lstlisting}[language=python]
from pycompss.api.task import task
from pycompss.api.parameter import *
%*{\bf @task }*)(f = FILE_INOUT)
def func(f, i):
     fd = open(f, 'r+')
     ...
\end{lstlisting}

If the function or method returns a value, the programmer must specify the type of that value using 
the {\it returns} argument of the {\it $@$task} decorator:

\begin{lstlisting}[language=python]
@task(%*{\bf returns }*) = int)
def ret_func():
     return 1
\end{lstlisting}

For tasks corresponding to instance methods, by default the task is assumed to modify the callee object 
(the object on which the method is invoked). The programmer can tell otherwise by setting the 
{\it isModifier} argument of the {\it $@$task} decorator to {\it False}.

\begin{lstlisting}[language=python]
class MyClass(object):
    ...
    @task(%*{\bf isModifier }*) = False)
    def instance_method(self):
        ... # self is NOT modified here
\end{lstlisting}

The programmer can also mark a task as a high-priority task with the {\it priority} argument of the 
{\it $@$task} decorator. This way, when the task is free of dependencies, it will be scheduled before 
any of the available low-priority (regular) tasks. This functionality is useful for tasks that are in 
the critical path of the application’s task dependency graph.

\begin{lstlisting}[language=python]
@task(%*{\bf priority }*) = True)
def func():
    ...
\end{lstlisting}

Table \ref{tab:task_decorator_arguments} summarizes the arguments that can be found in the $@$task decorator.
\bgroup
  \def\arraystretch{1.5}%
  \begin{longtable}{| p{0.31\textwidth} | p{0.69\textwidth} |}
    \hline
    \multicolumn{1}{|c|}{{\bf Argument }}    &  \multicolumn{1}{c|}{{\bf Value }}\\
    \hline
    \multirow{5}{*}{Formal parameter name}  &  - INOUT: read-write parameter, all types except file (primitives, strings, objects). \\
    & - OUT: read-write parameter, all types except file (primitives, strings, objects). \\
    & - FILE: read-only file parameter. \\
    & - FILE\_INOUT: read-write file parameter. \\
    & - FILE\_OUT: write-only file parameter. \\
    \hline
    returns & int (for integer and boolean), long, float, str, dict, list, tuple, user-defined classes \\
    \hline
    isModifier &  True (default) or False \\
    \hline
    priority  & True or False (default) \\
    \hline
    \caption{Arguments of the {\it $@$task} decorator.}
    \label{tab:task_decorator_arguments}
  \end{longtable}
\egroup


\subsubsection{Main Program}
The main program of the application is a sequential code that contains calls to the selected tasks. 
In addition, when synchronizing for task data from the main program, 
there exist two API functions that need to be invoked:

\begin{itemize}
 \item {\it compss\_open(file\_name, mode = 'r')}: similar to the Python {\it open()} call. It synchronizes
       for the last version of file {\it file\_name} and returns the file descriptor for that synchronized
       file. It can receive an optional parameter {\it mode}, which defaults to '{\it r}', containing the
       mode in which the file will be opened (the open modes are analogous to those of
       Python {\it open()}).
 \item {\it compss\_wait\_on(obj, to\_write = True)}: synchronizes for the last version of object {\it obj}
       and returns the synchronized object. It can receive an optional boolean parameter
       {\it to\_write}, which defaults to {\it True}, that indicates whether the main program will modify the
       returned object.
\end{itemize}

To illustrate the use of the aforementioned API functions, the following example first invokes a task 
{\it func} that writes a file, which is later synchronized by calling {\it compss\_open()}. 
Later in the program, an object of class {\it MyClass} is created and a task method {\it method} 
that modifies the object is invoked on it; the object is then synchronized with {\it compss\_wait\_on()}, 
so that it can be used in the main program from that point on.

\begin{lstlisting}[language=python]
from pycompss.api.api import compss_open, compss_wait_on

my_file = 'file.txt'
func(my_file)
fd = %*{\bf compss\_open}*)(my_file)
...

my_obj = MyClass()
my_obj.method()
my_obj = %*{\bf compss\_wait\_on}*)(my_obj)
...
\end{lstlisting}

The corresponding task selection for the example above would be:

\begin{lstlisting}[language=python]
@task(f = FILE_OUT)
def func(f):
    ...
    
    class MyClass(object):
        ...
        
        @task()
        def method(self):
            ... # self is modified here
\end{lstlisting}

Table \ref{tab:python_api_functions} summarizes the API functions to be used in the main program of a COMPSs Python application.
\bgroup
  \def\arraystretch{1.5}%
  \begin{longtable}{| p{0.45\textwidth} | p{0.5\textwidth} |}
    \hline
    \multicolumn{1}{|c|}{{\bf Function }}    &  \multicolumn{1}{c|}{{\bf Use }}\\
    \hline
    compss\_open(file\_name, mode = 'r') & Synchronizes for the last version of a file and returns its file descriptor. \\
    \hline
    compss\_wait\_on(obj, to\_write = True) & Synchronizes for the last version of an object and returns it. \\
    \hline
    \caption{COMPSs Python API functions.}
    \label{tab:python_api_functions}
  \end{longtable}
\egroup


\paragraph{Future Objects}
If the programmer selects as a task a function or method that returns a value, that value is not 
generated until the task executes. However, in order to keep the asynchrony of the task invocation, 
COMPSs manages future objects: a representant object is immediately returned to the main program when 
a task is invoked.

\begin{lstlisting}[language=python]
@task(%*{\bf returns }*) = MyClass)
def ret_func():
    return MyClass(...)

...

# %*{\bf o }*) is a future object
o = ret_func()
\end{lstlisting}

The future object returned can be involved in a subsequent task call, and the COMPSs runtime will automatically 
find the corresponding data dependency. In the following example, the future object o is passed as a parameter 
and callee of two subsequent (asynchronous) tasks, respectively:

\begin{lstlisting}[language=python]
# %*{\bf o }*) is a future object
o = ret_func()

...

another_task(o)

...

o.yet_another_task()
\end{lstlisting}

In order to synchronize the future object from the main program, the programmer proceeds in the same way 
as with any object updated by a task:

\begin{lstlisting}[language=python]
# %*{\bf o }*) is a future object
o = ret_func()

...

o = compss_wait_on(o)
\end{lstlisting}
                         
The future object mechanism is applied to primitive types, strings and objects (including the Python 
built-in types list, dictionary and tuple).

It is important to note that, for instances of user-defined classes, the classes of these objects 
should have an empty constructor, otherwise the programmer will not be able to invoke task instance 
methods on those objects:
                                   
\begin{lstlisting}[language=python]
class MyClass(object):
    def __init__(self): # empty constructor
        ...
        
    ...

o = ret_func()

# invoking a task instance method on a future object can only
# be done when an empty constructor is defined in the object's
# class
o.yet_another_task()
\end{lstlisting}

\subsubsection{Important Notes}
For the COMPSs Python binding to function correctly, the programmer should not use relative imports 
in her code. Relative imports can lead to ambiguous code and they are discouraged in Python, as explained in:

\begin{lstlisting}[language=html]
http://docs.python.org/2/faq/programming.html#what-are-the-best-practices-for-using-import-in-a-module
\end{lstlisting}


\subsection{Application Execution}
The next subsections describe how to execute applications with the COMPSs Python binding.

\subsubsection{Environment}
The following environment variables must be defined before executing a COMPSs Python application:

JAVA\_HOME: Java JDK installation directory (e.g. \textit{/usr/lib/jvm/java-7-openjdk/})

\subsubsection{Command}
In order to run a Python application with COMPSs, the script runcompss can be used, like for 
Java and C/C++ applications. An example of an invocation of the script is:

\begin{lstlisting}[language=bash]
compss@bsc:~$ runcompss \
                --lang=python \
                --classpath=$TEST_DIR \
                --library_path=/home/user/libdir \
                $TEST_DIR/test.py arg1 arg2
\end{lstlisting}

For full description about the options available for the runcompss command please check the \textit{COMPSs User Manual: Application
Execution} available at our webpage \url{http://compss.bsc.es} . 
